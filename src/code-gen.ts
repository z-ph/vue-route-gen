import type { RouteData, RouteEntry } from './route-builder.js';
import { toConstKey } from './utils.js';
import { valueToLiteralType } from './types.js';

interface RouteKeyEntry {
  key: string;
  name: string;
  path: string;
  defaultName: string;
}

/**
 * Render meta object as const for type inference
 */
function renderMetaAsConst(meta: Record<string, any>, indent: string): string {
  const nextIndent = `${indent}  `;
  const entries = Object.entries(meta).map(([key, value]) => {
    let valueStr: string;
    if (typeof value === 'string') {
      valueStr = JSON.stringify(value);
    } else if (typeof value === 'boolean' || typeof value === 'number') {
      valueStr = String(value);
    } else if (Array.isArray(value)) {
      valueStr = `[${value.map((v) => JSON.stringify(v)).join(', ')}]`;
    } else if (typeof value === 'object' && value !== null) {
      valueStr = JSON.stringify(value);
    } else {
      valueStr = JSON.stringify(value);
    }
    return `${nextIndent}${JSON.stringify(key)}: ${valueStr},`;
  });

  return `${indent}{
${entries.join('\n')}
${indent}} as const`;
}

/**
 * Render a single route entry as TypeScript code
 */
function renderRoute(finalRoute: RouteEntry, indent = '  '): string {
  const nextIndent = `${indent}  `;
  const metaStr =
    finalRoute.meta && Object.keys(finalRoute.meta).length > 0
      ? `${nextIndent}meta: ${renderMetaAsConst(finalRoute.meta, nextIndent)},\n`
      : '';

  const childrenStr =
    finalRoute.children.length === 0
      ? `${nextIndent}children: [],\n`
      : `${nextIndent}children: [
${finalRoute.children.map((child) => renderRoute(child, `${nextIndent}  `)).join(',\n')}
${nextIndent}],\n`;

  // Render optional fields
  const aliasStr = finalRoute.alias !== undefined
    ? `${nextIndent}alias: ${JSON.stringify(finalRoute.alias)},\n`
    : '';

  const redirectStr = finalRoute.redirect !== undefined
    ? `${nextIndent}redirect: ${renderValue(finalRoute.redirect, nextIndent)},\n`
    : '';

  const propsStr = finalRoute.props !== undefined
    ? `${nextIndent}props: ${renderValue(finalRoute.props, nextIndent)},\n`
    : '';

  const beforeEnterStr = finalRoute.beforeEnter !== undefined
    ? `${nextIndent}beforeEnter: ${finalRoute.beforeEnter},\n`
    : '';

  return `${indent}{
${nextIndent}path: ${JSON.stringify(finalRoute.path)},
${nextIndent}name: ${JSON.stringify(finalRoute.name)},
${aliasStr}${redirectStr}${propsStr}${nextIndent}component: () => import(${JSON.stringify(finalRoute.importPath)}),
${metaStr}${beforeEnterStr}${childrenStr}${indent}}`;
}

/**
 * Render a value (could be object, array, primitive) as code
 */
function renderValue(value: any, indent: string): string {
  if (value === null) {
    return 'null';
  }
  if (typeof value === 'string') {
    return JSON.stringify(value);
  }
  if (typeof value === 'boolean' || typeof value === 'number') {
    return String(value);
  }
  if (Array.isArray(value)) {
    return `[${value.map((v) => renderValue(v, indent)).join(', ')}]`;
  }
  if (typeof value === 'object') {
    const entries = Object.entries(value);
    if (entries.length === 0) return '{}';
    const nextIndent = `${indent}  `;
    const body = entries.map(([k, v]) => `${nextIndent}${JSON.stringify(k)}: ${renderValue(v, nextIndent)}`).join(',\n');
    return `{\n${body}\n${indent}}`;
  }
  return JSON.stringify(value);
}

/**
 * Render complete routes file as TypeScript code
 */
export function renderRoutesFile({
  routes,
  routeNameList,
  routePathList,
  routePathByName,
  routeParamsByName,
  routeKeyData,
}: RouteData): string {
  const routeKeyEntries: RouteKeyEntry[] = [];
  const usedKeys = new Set<string>();

  // Build map of route entries by name for quick lookup
  const entryMap = new Map<
    string,
    { name: string; path: string; defaultName: string }
  >();
  for (const entry of routeKeyData) {
    entryMap.set(entry.name, {
      name: entry.name,
      path: entry.path,
      defaultName: entry.defaultName,
    });
  }

  for (const name of routeNameList) {
    const entry = entryMap.get(name);
    if (!entry) continue;

    const baseKey = toConstKey(entry.defaultName) || 'ROUTE';
    let key = baseKey;
    let suffix = 1;
    while (usedKeys.has(key)) {
      suffix += 1;
      key = `${baseKey}_${suffix}`;
    }
    usedKeys.add(key);
    routeKeyEntries.push({
      key,
      name: entry.name,
      path: entry.path,
      defaultName: entry.defaultName,
    });
  }

  // Collect all unique meta keys across all routes
  const allMetaKeys = new Set<string>();
  for (const route of routes) {
    if (route.meta) {
      Object.keys(route.meta).forEach((key) => allMetaKeys.add(key));
    }
  }
  const sortedMetaKeys = Array.from(allMetaKeys).sort();

  return `// This file is auto-generated by @zphhpzzph/vue-route-gen.
// Do not edit this file directly.
import type { RouteRecordRaw, RouteLocationNormalizedLoaded, Router, LocationQuery } from 'vue-router';

export const ROUTE_NAME = {
${routeKeyEntries.map((entry) => `  ${entry.key}: ${JSON.stringify(entry.name)},`).join('\n')}
} as const;

export type RouteName = (typeof ROUTE_NAME)[keyof typeof ROUTE_NAME];

export const ROUTE_PATH = {
${routeKeyEntries.map((entry) => `  ${entry.key}: ${JSON.stringify(entry.path)},`).join('\n')}
} as const;

export type RoutePath = (typeof ROUTE_PATH)[keyof typeof ROUTE_PATH];

export const ROUTE_PATH_BY_NAME = {
${routeKeyEntries.map((entry) => `  ${JSON.stringify(entry.name)}: ROUTE_PATH.${entry.key},`).join('\n')}
} as const;

export type RoutePathByName = typeof ROUTE_PATH_BY_NAME;

export const routeNameList = [
${routeNameList.map((name) => `  ${JSON.stringify(name)},`).join('\n')}
] as const;

export const routePathList = [
${routePathList.map((path) => `  ${JSON.stringify(path)},`).join('\n')}
] as const;

export const routePathByName = {
${routePathByName.map(([name, pathValue]) => `  ${JSON.stringify(name)}: ${JSON.stringify(pathValue)},`).join('\n')}
} as const;

// Route parameter types
export interface RouteParams {
${Array.from(routeParamsByName)
  .map(
    ([name, params]) =>
      params.length > 0
        ? `  '${name}': {
${params.map((p) => `    ${p}: string;`).join('\n')}
  };`
        : `  '${name}': Record<string, never>;`
  )
  .join('\n')}
}

export type RouteParamsByName<T extends RouteName> = RouteParams[T];

// Route metadata types (extracted from <route> blocks)
// Uses literal types for precise type inference
// Missing fields are typed as undefined to ensure consistent shape
export interface RouteMetaMap {
${routes
  .map((route) => {
    const meta = route.meta || {};
    const metaFields = sortedMetaKeys
      .map((key) => {
        if (key in meta) {
          const literalType = valueToLiteralType(meta[key]);
          return `    ${key}: ${literalType};`;
        } else {
          return `    ${key}: undefined;`;
        }
      })
      .join('\n');
    return `  '${route.name}': {
${metaFields}
  };`;
  })
  .join('\n')}
}

export type RouteMetaByName<T extends RouteName> = RouteMetaMap[T];

export const routes = [
${routes.map((route) => renderRoute(route)).join(',\n')}
] satisfies RouteRecordRaw[];

export default routes;

// Type-enhanced hooks
import { useRoute as vueUseRoute, useRouter as vueUseRouter } from 'vue-router';

/**
 * Type-safe useRoute hook
 * Route params and meta are typed based on the current route name
 *
 * @example
 * \`\`\`ts
 * const route = useRoute();
 * // route.params.id is typed as string if route has :id param
 * // route.meta.title is typed based on the route's <route> block
 * \`\`\`
 */
export function useRoute<TName extends RouteName = RouteName>(
  _name?: TName
): Omit<RouteLocationNormalizedLoaded, 'params' | 'name' | 'meta'> & {
  name: TName;
  params: TName extends keyof RouteParams ? RouteParams[TName] : RouteParams[RouteName];
  meta: TName extends keyof RouteMetaMap ? RouteMetaMap[TName] : RouteMetaMap[RouteName];
} {
  return vueUseRoute() as any;
}

/**
 * Type-safe useRouter hook
 * Navigation methods are type-safe based on route names and params
 *
 * @example
 * \`\`\`ts
 * const router = useRouter();
 * router.push({
 *   name: ROUTE_NAME.USER_DETAIL,
 *   params: { id: '123' }
 * });
 * \`\`\`
 */
export function useRouter(): Omit<Router, 'push' | 'replace'> & {
  push: <TName extends RouteName>(location: {
    name?: TName;
    path?: string;
    params?: TName extends keyof RouteParams ? Partial<RouteParams[TName]> : Record<string, any>;
    query?: LocationQuery;
    hash?: string;
  }) => ReturnType<Router['push']>;
  replace: <TName extends RouteName>(location: {
    name?: TName;
    path?: string;
    params?: TName extends keyof RouteParams ? Partial<RouteParams[TName]> : Record<string, any>;
    query?: LocationQuery;
    hash?: string;
  }) => ReturnType<Router['replace']>;
} {
  const router = vueUseRouter();
  return router as any;
}
`;
}
